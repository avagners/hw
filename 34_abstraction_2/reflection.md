# Пять точных абстракций

## 1. Абстракция "Очередь сообщений" → "Обработка событий"

Эта абстракция позволяет смотреть на асинхронную обработку событий как на поток данных, а не как на набор отдельных вызовов функций.

```python
class EventQueue:
    """Абстракция: поток входящих событий, не зависящий от источника."""
    
    def __init__(self, source: EventSource):
        """source может быть Kafka, RabbitMQ, файлы логов и т.д."""
        self.source = source  

    def get_next_event(self) -> Event:
        """Абстракция: события системы → поток единиц работы"""
        return self.source.consume()
```

Почему это точная абстракция?
- Отображает не детальную реализацию очереди, а сам факт обработки событий.
- В коде, который её использует, не нужно знать, Kafka это или WebSocket.
- Мы можем сказать: "Система поддерживает потоковую обработку событий", не читая её детали.

## 2. Абстракция "Авторизация пользователя" → "Решение о доступе"

Мы не проверяем роли, пароли или токены напрямую. Мы работаем с решением "доступ разрешён/запрещён".

```python
class AuthorizationService:
    """Абстракция: система доступа решает, можно или нет."""

    def __init__(self, policy_engine: AccessPolicyEngine):
        """policy_engine может быть RBAC, ACL или кастомная логика."""
        self.policy_engine = policy_engine  

    def is_allowed(self, user: User, action: str) -> bool:
        """Абстракция: Пользователь → бинарное решение "можно/нельзя"."""
        return self.policy_engine.evaluate(user, action)  
```

Почему это точная абстракция?
- Она отделяет детали (типы политики, таблицы БД, JWT) от самого факта принятия решения.
- Мы можем сказать: "Авторизация построена на политиках", не читая код проверки токенов.

## 3. Абстракция "Бизнес-метрика" → "Реальные события в системе"

Мы не просто логируем числа. Мы фиксируем состояние бизнеса, например, количество активных пользователей.

```python
class MetricsCollector:
    """Абстракция: сбор и агрегация ключевых показателей работы системы."""

    def __init__(self, storage: MetricsStorage):
        """storage может быть Prometheus, InfluxDB или JSON-файлы."""
        self.storage = storage  

    def record_user_login(self, user_id: str):
        """Абстракция: факт входа пользователя → числовая метрика."""
        self.storage.increment("active_users")

    def record_transaction(self, amount: float):
        """Абстракция: факт транзакции → финансовая метрика."""
        self.storage.add("total_revenue", amount)
```

Почему это точная абстракция?
- В коде не говорится о конкретных системах мониторинга.
- Мы говорим "система фиксирует активность пользователей", а не "мы пишем логи в Prometheus".
- Это более высокий уровень мышления, чем просто "записать число".

## 4. Абстракция "Очередь задач" → "Динамическое управление нагрузкой"

Вместо управления потоками или горутинами напрямую, мы говорим о динамическом балансе нагрузки.

```python
class TaskQueue:
    """Абстракция: динамическое управление задачами без знания их природы."""

    def __init__(self):
        self.queue = Queue()

    def add_task(self, task: Callable):
        """Абстракция: реальная работа → управляемая единица исполнения."""
        self.queue.put(task)

    def execute_next(self):
        """Абстракция: балансировка нагрузки → динамическое исполнение."""
        task = self.queue.get()
        task()
```

Почему это точная абстракция?
- Мы видим не код управления потоками, а системное свойство: задачи исполняются динамически.
- Мы можем сказать "Система управляет нагрузкой через очередь задач", не читая реализацию потоков.

## 5. Абстракция "Статус платежа" → "Состояние бизнес-процесса"

Мы не оперируем низкоуровневыми HTTP-запросами или БД. Мы фиксируем само понятие состояния платежа.

```python
class PaymentStatus(Enum):
    """Абстракция: бизнес-состояние платежа."""
    PENDING = "ожидание"
    COMPLETED = "завершён"
    FAILED = "ошибка"

class PaymentProcessor:
    """Абстракция: бизнес-логика обработки платежей."""

    def __init__(self, gateway: PaymentGateway):
        self.gateway = gateway  

    def process_payment(self, user: User, amount: float) -> PaymentStatus:
        """Абстракция: факт платежа → состояние бизнес-процесса."""
        if self.gateway.charge(user, amount):
            return PaymentStatus.COMPLETED
        return PaymentStatus.FAILED
```

Почему это точная абстракция?
- Мы не думаем про `HTTP`, `API` и ошибки запросов. Мы работаем со статусами бизнес-процесса.
- Мы можем сказать: "Платёж проходит три стадии", не разбираясь в том, какой сервис его обрабатывает.

## Вывод
Каждая из этих абстракций: 
- позволяет рассуждать о системе на более высоком уровне;
- фиксирует ключевое системное свойство;


## Как я это понимаю определение абстракции Дейкстры?

Абстракция — это не про скрытие деталей, а про создание точного слоя смыслов.
- Если я вынес код в отдельный класс или функцию, но по-прежнему не могу точно сказать, что именно делает этот уровень, значит, это не абстракция, а просто организационный приём.
- Если же я могу сформулировать: "Этот модуль отображает поток сырых логов в поток нормализованных событий", значит, я создал настоящую абстракцию.

Хорошая абстракция позволяет рассуждать о системе без оглядки на реализацию.
- Например, если у меня есть `TaskQueue`, мне не нужно думать о потоках, блокировках и синхронизации — достаточно знать, что задачи будут выполняться динамически.
- Если у меня есть `PaymentStatus`, я не задумываюсь, использует ли система `Stripe` или `PayPal` — у платежа просто есть состояние.

Абстракция создаёт новый семантический уровень, позволяющий формулировать точные вопросы и ответы.
- Плохой уровень: "Как работает этот код?"
- Хороший уровень: "Какую семантическую гарантию даёт этот слой?"

## Как я буду применять это в практике?
1) Формулировать точную семантику перед рефакторингом.
- Прежде чем выделять новый класс или интерфейс, я буду задавать вопрос: "Какое новое свойство системы он фиксирует?"
- Если такого свойства нет, а код просто организован иначе — это не абстракция, а перестановка строк.

2) Оценивать абстракции не по коду, а по тому, как они меняют мышление.
- Если после введения абстракции вопросы о системе стали проще и точнее — значит, она удалась.
- Если разработчики всё равно вынуждены проваливаться в детали реализации, значит, абстракция неудачна.

3) Стремиться к абстракциям, которые не зависят от технических деталей.
- Хорошая абстракция должна быть актуальна даже при смене технологий.
- Если после перехода с `MySQL` на `PostgreSQL` вся логика хранения пользователей не изменилась — значит, "модель пользователя" была правильной абстракцией, а "таблица в БД" — нет.