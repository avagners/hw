# Отладка как наука

## 1: "Пропадающие" данные в отчете (ETL процесс)

Проблема:  
Ежедневный отчет иногда показывал "0" для определенного показателя, хотя данные в источнике были. Ошибка происходила не каждый день, без явной закономерности.

Узкие гипотезы (первоначальные):
- "Ошибка в формуле расчета показателя в SQL-запросе отчета."
- "Сбой при загрузке данных из источника X в промежуточный слой."
- "Проблема с правами пользователя, запускающего отчет."

Широкий вопрос:  
"Отличается ли состояние источника данных или процесса его извлечения в моменты, когда отчет показывает '0', от моментов, когда он показывает корректные данные?"

Что проверяет:  
Этот вопрос охватывает огромный класс причин: проблемы подключения к источнику, таймауты, изменения схемы источника, неполные/битые данные на входе, сбои в процессе извлечения (ETL), блокировки таблиц, проблемы с сетью между источником и ETL-сервером.

Проверка:  
Вместо анализа SQL или прав, мы начали логировать статус подключения к источнику, время выполнения этапа извлечения, количество полученных строк и хэш контрольной суммы небольшой выборки данных перед их обработкой для каждого запуска. Сравнили логи успешных и неудачных дней.

Результат:  
Логи показали, что в дни с "0" количество строк из источника было значительно меньше ожидаемого. Это отбросило все гипотезы, связанные с обработкой после извлечения (SQL отчета, расчеты в ETL после загрузки). Фокус сузился до проблем до или во время извлечения. Оказалось, что источник иногда не успевал формировать полный снимок данных к моменту запуска ETL.

## 2: Случайные таймауты API

Проблема:  
Внешние клиенты периодически получали таймауты при вызове нашего API. Воспроизвести локально или на тестовых стендах не удавалось. Ошибки были редкими, но критичными.

Узкие гипотезы (первоначальные):
- "Проблема в конкретном endpoint /api/v1/order."
- "Утечка памяти/ресурсов в воркере приложения."
- "Сетевой сбой между балансировщиком и бекендом."

Широкий вопрос:  
"Связаны ли таймауты с характеристиками самого запроса или внешними условиями (инфраструктура, нагрузка, другие процессы), а не с обработкой его бизнес-логикой?"

Что проверяет:  
Этот вопрос делит пространство ошибок на два огромных лагеря:  
1) Проблемы внутри кода обработки запроса (бизнес-логика, доступ к БД, кэш) и  
2) Проблемы вовне (сеть, балансировка, инфраструктура, ОС, соседние процессы, нагрузка).

Проверка:  
Включили детальное логгирование времени жизни запроса на всех уровнях (балансировщик -> бекенд -> БД/кэш) + метрики инфраструктуры (CPU, память, сеть, IO) на момент таймаута. Искали корреляции.

Результат:  
Анализ показал, что таймауты происходили только на запросах с большим размером тела (>1MB) и только когда нагрузка на сетевой интерфейс сервера превышала 80%. Это отбросило гипотезы, связанные с конкретным endpoint или утечками в коде приложения. Проблема оказалась в конфигурации сетевой очереди ОС на серверах под высокой нагрузкой для больших пакетов.

## 3: "Прыгающий" элемент UI

Проблема: В веб-приложении определенный элемент интерфейса (кнопка) иногда резко смещался в сторону при первом рендеринге страницы. Ошибка была плавающей, зависела от размера окна браузера и разрешения.

Узкие гипотезы (первоначальные):
- "Ошибка в CSS-стилях для этой конкретной кнопки."
- "Конфликт с какой-то JS-библиотекой (например, каруселью рядом)."
- "Проблема с расчетом размеров родительского контейнера."

Широкий вопрос:  
"Связано ли смещение элемента с динамикой загрузки данных/контента или последовательностью рендеринга/применения стилей, а не с его статическими стилями?"

Что проверяет:  
Этот вопрос охватывает класс причин, связанных с временными аспектами: задержка загрузки данных (AJAX), асинхронное применение стилей или скриптов, "всплытие" (layout thrashing) из-за чтения/записи геометрии DOM до стабилизации страницы, отложенная инициализация компонентов.

Проверка:  
Вместо копания в статических стилях, мы:
- Записывали видео/скриншоты процесса загрузки страницы с помощью DevTools (видеозапись рендеринга).
- Логировали время загрузки данных для элемента/его контекста.
- Проверяли, происходит ли смещение, если искусственно замедлить загрузку данных или выполнение JS.

Искали в коде места, где могло происходить чтение геометрии (offsetWidth и т.п.) до завершения рендеринга.

Результат:  
Видео и замедление показали, что смещение происходит в момент позднего поступления данных для соседнего виджета, который вызывал перерасчет макета после первоначальной отрисовки кнопки. Это отбросило гипотезы о статических CSS-ошибках или конфликтах библиотек. Проблема была в неоптимальной последовательности загрузки данных и рендеринга компонентов.

## Выводы

Отладка — это навык мышления, а не знания кода.  
Это не «гадание», а цикл: **Наблюдение → Гипотеза → Эксперимент → Верификация.**

Ошибаться — полезно, если ошибка исключает целый класс проблем.

Вместо:
"Падает ли из-за того, что `user.id is None`?"  *# Узкий (исключает 1 причину)*  
Надо:
"Зависит ли ошибка от *состояния объекта* перед вызовом функции?"  *# Широкий (исключает 20+ причин)*

Формулирование широкого вопроса заставляет сместить фокус с конкретного "подозреваемого" на поиск фундаментальных различий между состояниями системы, когда ошибка есть и когда ее нет. Это различие (в состоянии источника данных, характеристиках запроса, динамике загрузки) часто указывает на целый класс системных или процессных причин, проверка которых исключает десятки узких гипотез разом. Хотя проверить широкий вопрос часто сложнее технически, его диагностическая ценность при ложном ответе (а они часто ложны на первых итерациях!) неизмеримо выше.