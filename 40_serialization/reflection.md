# Об опасности стандартных подходов

## В проекте

В моем текущем проекте ключевые структуры данных не всегда явно присутствуют в коде. Они зачастую скрыты за слоями сериализации.

В коде сервиса есть модели конфигурации серверов и пользователей. Они описаны как Python-классы и используются в логике приложения. Например, в FastAPI у нас есть такие Pydantic-модели:

```python

from pydantic import BaseModel

class VPNServer(BaseModel):
    country: str
    ip_address: str
    protocol: str
```

С другой стороны, некоторые данные не присутствуют в коде напрямую, а формируются динамически. 
Например конфигурации генерируются в процессе работы, а не хранятся в коде.

```python
from fastapi import FastAPI
import json

app = FastAPI()

@app.get("/server/config/{server_id}")
def get_server_config(server_id: str):
    config = {
        "server_id": server_id,
        "settings": {"protocol": "wireguard", "port": 51820}
    }
    return json.dumps(config)  # Данные превращаются в строку, а не объект
```

Здесь структура данных фактически отсутствует в коде — она создается на лету и передается как сериализованный JSON.

## REST API без глобального хранилища данных и ORM

1) Контекстно-ограниченные ссылки (scoped references)
Если пользователь запрашивает свои данные, зачем ему знать ID? Можно сделать так, чтобы сервер сам понимал, что за пользователь и какие у него данные.

Вместо того чтобы дергать что-то вроде:

```http
GET /subscriptions/12345
```

можно обращаться так:

```http
GET /subscriptions/current
```

Бэкенд сам поймет по токену пользователя, какая подписка активна, и вернёт нужные данные.

2) Содержательная адресация (content-based addressing)

Обычно у объектов есть свойства, которые сами по себе уникальны.
Если имя пользователя уникальное, это позволяет API быть удобнее и понятнее.

Вместо:
```http
GET /users/123
```
можно делать:

```http
GET /users/alex
```
3) Хеширование данных (immutable IDs)

Глобальные ID-шники не нужны, если можно генерировать уникальные идентификаторы на основе содержимого объекта.

Как это выглядит?
Вместо автоинкрементных ID можно использовать хеши, например, SHA256 от основных атрибутов:

```http
GET /documents/3f78a914d0c6b
```
Это даёт преимущества: нет централизованного генератора ID, нет риска коллизий.

4) Автономные клиентские структуры (client-side state management)

Вместо хранения промежуточных данных на сервере можно отдавать управление клиенту.
Вместо того чтобы создавать заказ и ждать его ID, можно передавать всё в теле запроса:

```http
POST /checkout
{
  "items": [
    { "product": "premium", "duration": "1 year" }
  ]
}
```
Сервер обрабатывает этот заказ без привязки к какому-либо глобальному идентификатору.

5) Event-sourcing вместо CRUD

Обычно REST API ориентированы на изменения состояния (CRUD), но можно строить API вокруг событий.

Вместо:

```http
POST /users
{
  "email": "user@example.com"
}
```
можно отправлять событие:

```http
POST /events
{
  "type": "user.registered",
  "data": { "email": "user@example.com" }
}
```
База данных в этом случае вообще может не быть основным способом хранения данных — всё будет храниться как поток событий.

## Выводы

Раньше я думал, что REST API — это просто CRUD с ID и JSON. Теперь я вижу, что можно строить архитектуру по-разному: данные могут существовать в коде или быть "спрятанными" в процессах сериализации, а API можно организовать без привязки к глобальному хранилищу. Это не только избавляет от лишней централизации, но и упрощает масштабирование и отказоустойчивость системы. Особенно мне понравился вариант с хешами.