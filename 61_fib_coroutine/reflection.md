# Задачка N 0

Я раньше не сталкивался с корутинами и `yield` `from/send`. Пришлось разбираться с нуля.
Долго смотрел на код и запускал его по шагам.

Главное - в текущей реализации `get_fibs()` не возвращает последовательность чисел Фибоначчи.
Функция расчитывает накопленную сумму чисел Фибоначчи и возвращает последовательность сумм.

## 1. Логика работы алгоритма
```python
def fibs_sum():
    fsum = 0  # Инициализируем накопитель суммы
    while True:
        # yield приостанавливает выполнение и возвращает текущее значение fsum
        # При следующем вызове send(value) значение подставится вместо yield, 
        # и выполнится fsum += переданное_значение
        fsum += yield fsum  
     
def get_fibs(num):
    a, b = 0, 1  # Инициализируем начальные значения Фибоначчи
    gsum = fibs_sum()  # Создаем генератор-корутину

    gsum.send(None)  # "Разогрев" корутины - доходим до первого yield
    for i in range(num):
        # Отправляем текущее значение b в корутину и получаем актуальную сумму
        yield gsum.send(b)
        # Вычисляем следующее число Фибоначчи
        c = b
        b = a + b
        a = c
```

## Если функция должна возвращать последовательность сумм чисел Фибоначчи.

Что должно получаться:
Для `n=5`: числа Фибоначчи `[0, 1, 1, 2, 3]`, а их накопленная сумма `[0, 1, 2, 4, 7]`

Что получается на самом деле:
Запустил код - получается `[1, 2, 4, 7, 12]`. Это неправильно.

Мы сначала отправляем `b` ДО вычисления следующего числа.
Из-за этого:
 - На шаге 0: отправляем b=1 (вместо a=0)
 - На шаге 1: отправляем b=1 (хотя должны 1)
 - На шаге 2: отправляем b=2 (хотя должны 1)

Получается, мы пропускаем ноль и смещаем всю последовательность.

## Если функция должна расчитывать последовательность Фибоначчи (согласно условию).

В `get_fibs()` мы yield’им результат `gsum.send(b)`, а это - текущая накопленная сумма, а не число Фибоначчи `b`.

Поэтому следует yield’ить само число Фибоначчи, а не сумму `gsum.send(b)`. 

Но тут нас ждет вторая ошибка. Верная последовательность Фибоначчи начинается с 0 и для `get_fibs(5)` ответ должен быть `[0, 1, 1, 2, 3]`
Сейчас мы получаем `[1, 1, 2, 3, 5]`.

Это из-за того, что сначала yield’ится `b = 1`, а не `a = 0`. 

Если заменить переменную на `a`, то в итоге получаем правильную последовательность Фибоначчи `[0, 1, 1, 2, 3]`.

# Вывод 
Ошибка в том, что `yield` в `get_fibs()` возвращает не число Фибоначчи, а результат корутины-сумматора при этом есть еще одна ошибка со сдвигом всей последовательности.

Исправленный вариант кода ниже (изменения отметил комментариями).
yield’им число Фибоначчи `a` в `get_fibs()`.
```python
def fibs_sum():
    fsum = 0
    while True:
        fsum += yield fsum
     
def get_fibs(num):
    a, b = 0, 1
    gsum = fibs_sum()

    gsum.send(None)
    for i in range(num):
        gsum.send(a) # просто отправляем текущее число Фиббоначи в корутину-сумматор
        yield a # отдаем наружу текущее число Фиббоначи (начиная с 0)
        c = b
        b = a + b
        a = c

# Пример
print(list(get_fibs(5)))  # [0, 1, 1, 2, 3]
```

P.s. остался вопрос в нужности сумматора.  
Нужен ли он в данном случае, если функция `get_fibs()` должна возвращать последовательность Фибоначчи?
Нужен ли этот побочный эффект в данной функции?
