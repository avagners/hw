# ISP с т.зр. ФП

## Пример 1. Обработка данных (Data Processor)

Был класс `DataProcessor`, который умел читать данные из CSV, парсить их, валидировать и сохранять в базу. Его интерфейс включал методы для всех этих шагов.

Проблема:  
Клиенту, которому нужно только валидировать данные из уже готового списка словарей, приходилось реализовывать (или зависеть от) методы чтения CSV и сохранения в БД.

Решение:  
1) Разделил интерфейсы (ISP). Создал три отдельных протокола (абстрактных интерфейса):

- `DataReader[T]` (с одним методом `read() -> T`): Отвечает только за чтение данных из источника.
- `DataValidator[T]` (с одним методом `validate(data: T) -> bool`): Отвечает только за валидацию данных.
- `DataWriter[T]` (с одним методом `write(data: T) -> None`): Отвечает только за запись данных.

2) Сделал их обобщёнными: Вместо конкретных типов (`List[Dict], pd.DataFrame`) использовал дженерик `T`. Это позволяет:
- `CSVReader` реализовать `DataReader[List[Dict]]`.
- `DataFrameValidator` реализовать `DataValidator[pd.DataFrame]`.
- `DatabaseWriter` реализовать `DataWriter[Any]` (если может писать что угодно).

Теперь каждый интерфейс имеет одну цель (чтение, валидация, запись — SRP), но при этом максимально обобщён через параметр типа `T`, что позволяет комбинировать их для разных форматов данных.

## Пример 2. Система оповещений (Notifier)

Был класс `Notifier` с методами `send_email(), send_sms(), send_push(), log_notification()`.

Проблема:  
Компоненту, который только логирует события, всё равно нужно было знать о методах отправки.

Решение:  
1) Разделил интерфейсы (ISP). 
Определил два ключевых протокола:
- `MessageSender` (с одним методом `send(message: str) -> None`): Отвечает только за отправку сообщения в какой-либо канал.
`EventLogger` (с одним методом `log(event: LogEvent) -> None`): Отвечает только за логирование события.

2) Сделал их обобщёнными:
- `MessageSender` работает с абстрактной строкой `message`. Конкретные реализации (`EmailSender`, `SMSSender`) знают детали своего канала, но клиент зависит только от абстракции "отправить строку".
- `EventLogger` работает с абстрактным типом `LogEvent` (`dataclass` или `NamedTuple`), который содержит только необходимые для логирования поля (`level`, `message`, `timestamp`). Это позволяет не зависеть от всей сложной бизнес-модели "уведомления".

Теперь интерфейсы узконаправленны (отправка vs. логирование - SRP), но параметризованы абстрактными типами данных (`str`, `LogEvent`), что делает их применимыми в самых разных контекстах, а не только для системы оповещений.

## Пример 3. Кэширование (Cache)

Использовался интерфейс `Cache` с методами `get(key: str), set(key: str, value: Any), delete(key: str), clear(), get_stats()`.

Проблема:  
Для простого сценария "положить-получить" приходилось тащить за собой методы управления жизненным циклом (`clear`) и метриками (`get_stats`).

Решение:

1) Разделил интерфейсы (ISP). Выделил базовый протокол:
- `KeyValueStorage[K, V]` (с методами `get(key: K) -> V | None и set(key: K, value: V) -> None`). Это минимальный интерфейс для операции "ключ-значение".

2) Создал расширяемые интерфейсы. На его основе можно строить более специфичные, но тоже маленькие интерфейсы:
- `MutableStorage[K, V]` (наследует `KeyValueStorage` и добавляет `delete(key: K)`).
- `ManageableStorage` (добавляет `clear()`).
- `MonitorableStorage` (добавляет `get_stats() -> CacheStats`).

В итоге базовый интерфейс имеет одну, чёткую цель - обеспечить доступ по ключу (SRP). При этом он максимально обобщён через дженерики `K` и `V` (работает с любыми хешируемыми ключами и любыми значениями). Более сложное поведение добавляется через композицию маленьких интерфейсов, а не один большой "божественный" интерфейс.

## Выводы 

Раньше я боялся дженериков и абстрактных типов, думал, что они усложняют код. Теперь я вижу, что:
- `DataReader[T]` (обощенный) проще и полезнее, чем `CSVReader` (конкретный)
- `Filter[T]` можно использовать для продуктов, пользователей, заказов - для чего угодно

Когда интерфейс маленький и обобщённый:
- Моки создаются за секунды (всего 1-2 метода)
- Можно тестировать компоненты изолированно
- Легко подменять реализации (сегодня `SimpleCache`, завтра `RedisCache`)

Когда я вижу в сигнатуре метода:

```python
def process_data(
    reader: DataReader[str],
    transformer: DataTransformer[str, list],
    writer: DataWriter[list]
) -> None:
```
то я понимаю:
- Какие возможности нужны каждому аргументу
- Что функция будет делать (читать → трансформировать → писать)
- Как её тестировать (подставить моки для каждого интерфейса)

Раньше изменение интерфейса означало "поправить 20 классов". Теперь:
- Изменяю маленький интерфейс → затрагиваю только его реализации
- Добавляю новую функциональность → создаю новый интерфейс, а не расширяю старый
- Стабильность: базовые интерфейсы (ReadableCache) почти никогда не меняются

Главное:
Хороший интерфейс - не тот, который может всё, а тот, который делает одну вещь, делает её хорошо, и может работать с многими типами данных.

Это как в строительстве: лучше иметь набор специализированных инструментов (маленьких интерфейсов), которыми можно комбинировать, чем один "мультитул", который неудобен для конкретных задач.