# Избавляемся от stateful через глобальное состояние

## Пример 1. Замена локального состояния класса на глобальное хранилище (например, Redis)

Исходный код (с локальным состоянием):

```python
class Counter:
    def __init__(self):
        self._count = 0
    
    def increment(self):
        self._count += 1
        return self._count

# Использование
counter = Counter()
print(counter.increment())  # 1
print(counter.increment())  # 2
```

Рефакторинг (глобальное состояние в Redis):

```python
import redis

# Подключение к Redis (внешнее хранилище)
r = redis.Redis(host='localhost', port=6379, db=0)

def increment_counter(counter_id="default"):
    count = r.incr(counter_id)
    return count

# Использование
print(increment_counter())  # 1
print(increment_counter())  # 2
```

Что изменилось:
- Состояние `_count` больше не хранится в классе, а вынесено в `Redis`.
- Теперь состояние персистентно (переживает перезапуск программы) и доступно из разных процессов.

## Пример 2. Замена замыканий (неявное состояние) на глобальное хранилище (SQLite)

Исходный код (с замыканием):

```python
def make_counter():
    count = 0  # неявное состояние в замыкании
    
    def increment():
        nonlocal count
        count += 1
        return count
    
    return increment

# Использование
counter = make_counter()
print(counter())  # 1
print(counter())  # 2
```

Рефакторинг (глобальное состояние в SQLite):

```python
import sqlite3

# Инициализация БД
conn = sqlite3.connect(":memory:")
conn.execute("CREATE TABLE IF NOT EXISTS counters (id TEXT PRIMARY KEY, value INTEGER)")

def increment_counter(counter_id="default"):
    # Атомарно увеличиваем значение
    conn.execute(
        "INSERT OR REPLACE INTO counters VALUES (?, COALESCE((SELECT value FROM counters WHERE id = ?), 0) + 1)",
        (counter_id, counter_id)
    )
    conn.commit()
    return conn.execute("SELECT value FROM counters WHERE id = ?", (counter_id,)).fetchone()[0]

# Использование
print(increment_counter())  # 1
print(increment_counter())  # 2
```

Что изменилось:
- Состояние count теперь хранится в SQLite, а не в замыкании.
- Можно легко добавлять новые счетчики (просто меняя counter_id).

## Выводы

Мне всегда казалось, что глобальное состояние - это зло, а все данные нужно хранить локально: в переменных класса, замыканиях или стейт-менеджерах внутри приложения. Но чем сложнее становились проекты, тем больше я сталкивался с проблемами:
- Потеря состояния при перезапуске программы.
- Сложность отладки - куда делось значение переменной?
- Проблемы масштабирования - как синхронизировать состояние между сервисами?

После изучения подхода "все важные состояния — в глобальное хранилище" я понял:
- Локальное состояние - это скрытая сложность.
- Глобальное состояние - это не всегда плохо.

Если хранить глобальное состояние правильно (Redis, SQLite, БД), то:
- Легче дебажить - можно заглянуть в хранилище и увидеть текущие данные.
- Проще масштабировать - несколько сервисов могут работать с одним источником истины.
- Сохраняется после перезапуска - не нужно придумывать механизмы сериализации.

При этом понимаю, что не стоит всё пихать в Redis. Если переменная временная (кеш, промежуточные вычисления), можно оставить её в памяти. Но если данные важные (настройки, счетчики, сессии), лучше хранить их глобально.

Раньше я боялся глобального состояния, но теперь вижу в нём инструмент, а не антипаттерн. Главное - использовать его осознанно.

Спасибо!