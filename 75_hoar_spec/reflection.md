# Логика Хоара для программистов

## 1. Функция TaskProcessing.create_task
```python
# Предусловие: { initiator_id - валидный ID, cmd_plugin/cmd_name - не пустые, team_id - существует, зависимости инициализированы }
async def create_task(
        self, cmd_plugin: str, cmd_name: str, cmd_args, initiator_id: ct.UserId, msg_payload: t.Dict,
        team_id: str = 'DLK'
) -> None:
    # ... реализация ...
# Постусловие: { задача сохранена в репозитории, событие успеха или ошибки отправлено в диспетчер, исключения не выбрасываются }
```
### Анализ использования
Функция используется в `InitiatorBotPlugin.create_task`:
```python
try:
    # ... парсинг и валидация ...
    await self._task_processing.create_task(...)
except Exception as e:
    logger.error(e)
    self._task_processing.incorrect_filled_task(...)
```
Комментарий:
Здесь наблюдается частичное дублирование ответственности за обработку ошибок. Спецификация `create_task` гарантирует, что исключения не покинут пределы функции (блок `try...except...finally` внутри `create_task` перехватывает `Exception`). Однако вызывающий код (`InitiatorBotPlugin`) также оборачивает вызов в `try...except`.
Это приводит к тому, что блок `except` в плагине является "мертвым кодом" для ошибок, возникающих *внутри* `create_task`. Если `create_task` отработает с ошибкой (например, база данных недоступна), она отправит событие `TaskProcessedError`, но не выбросит исключение, и `incorrect_filled_task` в плагине вызван не будет. Это может вводить в заблуждение разработчика, читающего код плагина и ожидающего, что ошибки создания задачи обрабатываются именно там.

---

## 2. Метод TaskLocator.get_by_post_id

```python
# Предусловие: { cache_key - строка (ID поста), кэш инициализирован }
def get_by_post_id(self, cache_key: str) -> t.Optional[models.Task]:
    # ... реализация ...
# Постусловие: { возвращает Task если найден и открыт; выбрасывает CouldNotProcessingTask если не найден или закрыт; удаляет закрытую задачу из кэша }
```
### Анализ использования
Используется, например, в `InitiatorBotPlugin._cancel_task`:
```python
try:
    # ...
    task = self._task_locator.get_by_post_id(task_post_id)
    # ...
except exceptions.CouldNotProcessingTask:
    self._not_found_task_reply(message)
```
Комментарий:
Вызывающий код корректно обрабатывает спецификацию исключения: если задача не найдена или закрыта, пользователю отправляется сообщение "Мы не смогли найти эту заявку".
Однако скрытый побочный эффект (очистка кэша при обращении к закрытой задаче) не очевиден из названия метода (get_...). Это пример нарушения принципа `Command-Query Separation (CQS)` на уровне спецификации: метод чтения меняет состояние. Если бы вызывающий код просто проверял наличие задачи, он мог бы случайно удалить её из кэша для других потребителей (хотя в данном контексте это, вероятно, желаемое поведение для очистки мусора).

---

## 3. Метод User.can_independently_execute
```python
# Предусловие: { plugin, cmd - строки }
def can_independently_execute(self, plugin: str, cmd: str) -> bool:
    # ... реализация ...
# Постусловие: { возвращает True если команда в whitelist или есть активное разрешение AllowedCommand, иначе False }
```
### Анализ использования
Используется в `TaskProcessing.create_task` для определения маршрута заявки:
```python
if (user_initiator.can_independently_execute(plugin=cmd_plugin, cmd=cmd_name) or ...):
    # Создание задачи для самостоятельного выполнения
else:
    # Создание задачи на дежурного
```
Комментарий:
Стыковка спецификаций здесь выполнена чисто. Вызывающий код полностью полагается на булевый результат для ветвления бизнес-логики.
Стоит отметить, что спецификация метода содержит "магические знания" о конкретных плагинах (`airflow2`,`adp-information-desk`), что делает доменную модель зависимой от конкретных названий плагинов. Это ослабляет модульность, но с точки зрения контракта вызова (`bool`) проблем нет.

---

## 4. Метод TaskOrmRepository.get_by_id
```python
# Предусловие: { id_ - идентификатор задачи }
async def get_by_id(self, id_) -> models.Task:
    # ... реализация ...
# Постусловие: { возвращает Task если найден в БД, иначе выбрасывает CouldNotProcessingTask }
```

### Анализ использования
Используется внутри того же класса в методе `find_by_id`:
```python
async def find_by_id(self, id_: ct.TaskId) -> t.Optional[models.Task]:
    try:
        task = await self.get_by_id(id_)
        return task
    except exceptions.CouldNotProcessingTask:
        return
```
Комментарий:
Здесь происходит адаптация спецификации. Метод `get_by_id` имеет строгую спецификацию (объект или исключение), что удобно для сценариев, где отсутствие задачи - это ошибка. Метод `find_by_id` ослабляет постусловие до `Optional[Task]`, подавляя исключение. Это хороший пример явного управления контрактами: есть метод для "жесткого" получения (`expect existing`) и для поиска (`try find`).

---

## 5. Метод InitiatorBotPlugin._parse_query
```python
# Предусловие: { text - строка сообщения }
def _parse_query(self, text: str) -> t.List[str]:
    # ... реализация ...
# Постусловие: { возвращает список строк (>=3 элементов), если 3 элемента - добавляет 'DLK', выбрасывает FillRequisitionError если <3 }
```
### Анализ использования
Используется в `create_task`:
```python
service, command, args, team_id = self._parse_query(message.text)
```
Комментарий:
Здесь есть потенциальная проблема стыковки спецификаций. Вызывающий код использует распаковку списка в 4 переменные (`service, command, args, team_id`), что неявно требует, чтобы `_parse_query` возвращал список длиной ровно 4.
Однако спецификация `_parse_query` гарантирует только нижнюю границу (`>= 3`) и добавление дефолтного значения для 3 элементов. Если пользователь введет текст, в котором регулярное выражение сработает 5 раз, `_parse_query` вернет список из 5 элементов, и вызывающий код упадет с `ValueError: too many values to unpack`.
Хотя это исключение будет перехвачено общим `except Exception`, это пример "Ошибки модульного рассуждения": глядя на `_parse_query`, нельзя гарантировать успешную работу вызывающего кода во всех допустимых случаях (когда матчей > 4). Требуется ужесточить постусловие `_parse_query` (обрезать лишнее или валидировать длину) или изменить способ вызова.

---

## Итоги

Прочитав материал о спецификациях и логике Хоара, я понимаю, почему мой код иногда ломается в самых неожиданных местах, хотя "вроде бы всё работает".

Раньше я думал о коде только на уровне "запустил - работает". Теперь я вижу, что есть уровень логики, который гораздо строже. Анализируя этот проект, я заметил, что мы часто полагаемся на неявные знания: "ну, тут всегда вернется 4 элемента" или "эта функция точно не упадет". Но спецификации говорят об обратном.

Главный инсайт: код может быть рабочим, но некорректным. Например, `_parse_query` работает в 99% случаев, но логически она не гарантирует, что вернет ровно 4 элемента, и это бомба замедленного действия. А дублирование `try-except` в `create_task` показывает, что мы не доверяем собственным контрактам функций.

Внедрение явных пред- и пост-условий (хотя бы в голове или комментариях) помогает увидеть эти "дыры" в логике еще до того, как они превратятся в баги на проде. Это переключает мышление с "как написать, чтобы заработало" на "какие гарантии я даю и какие требую".