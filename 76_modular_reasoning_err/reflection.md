# Ошибки модульного рассуждения

## 1. Неявная зависимость от глобального состояния в TeamsDutyCalendars
```python
class TeamsDutyCalendars:
    # ...
    def get_main_duty_person(self, team: str, dttm: datetime, stream_code: t.Optional[str]) -> t.Optional[DutyPerson]:
        if team not in self._calendars:
            return None
        # ...
```
Проблема:
Класс `TeamsDutyCalendars` спроектирован как синглтон (глобальная переменная `teams_duty_calendars` создается в конце). Метод `get_main_duty_person` полагается на то, что словарь `self._calendars` был предварительно заполнен через метод `add_calendar`.
Однако, глядя только на код `get_main_duty_person` или даже на класс `TeamsDutyCalendars`, невозможно понять, *кто*, *когда* и *какими данными* заполняет этот календарь. Корректность работы `get_main_duty_person` (вернет ли он дежурного или None) зависит от побочных эффектов, происходящих где-то в другом месте программы (вероятно, при инициализации приложения).
Это классическая ошибка модульного рассуждения: мы не можем гарантировать поведение метода, не зная всей истории инициализации глобального объекта.

Как исправить:
Внедрить зависимость через конструктор (`Dependency Injection`). Вместо использования глобального синглтона, передавать инициализированный экземпляр `TeamsDutyCalendars` (или абстракцию `IDutyCalendarRepository`) в те классы, которые в нем нуждаются (например, в `TaskProcessing`). Заполнение календаря данными должно происходить явно на этапе конфигурации приложения (`Composition Root`), а сам класс не должен быть глобально доступным.

## 2. Скрытая зависимость от формата вывода внешней команды в ParamikoExecutor
```python
class ParamikoExecutor(ITaskExecutor):
    # ...
    async def execute(self, task: models.Task) -> None:
        # ...
        elif return_code == CommandReturnCodes.PLUGIN_CMD_EXECUTOR_ERROR:
            stdout_str = stdout.read().decode()
            if "validator" in task._command.name:
                raise exceptions.TaskValidationError(stdout_str.split("[224]")[-1].strip())
            # ...
```
Проблема:
Метод `execute` парсит вывод внешней команды (`stdout`), ожидая найти там специфический разделитель `[224]`.
Глядя на код ParamikoExecutor, мы видим зависимость от "магической строки" `[224]`. Спецификация `ITaskExecutor.execute` ничего не говорит о формате ошибок. Корректность этого кода полностью зависит от реализации *внешних скриптов/плагинов*, которые выполняются через SSH. Если внешний скрипт изменит формат вывода ошибки (например, уберет `[224]`), этот код сломается или вернет некорректное сообщение об ошибке. Мы не можем судить о корректности `ParamikoExecutor` изолированно; нам нужно знать детали реализации всех внешних плагинов.

Как исправить:
Формализовать контракт взаимодействия с внешними плагинами. Вместо парсинга произвольного текста с магическими разделителями, требовать от плагинов возвращать структурированный ответ (например, JSON) в `stdout` или `stderr`.
Пример:
```python
# Ожидаем JSON вида: {"error_code": 224, "message": "Validation failed", "details": "..."}
try:
    error_data = json.loads(stdout_str)
    if error_data['error_code'] == 224:
        raise exceptions.TaskValidationError(error_data['message'])
except json.JSONDecodeError:
    # Fallback или ошибка протокола
```
Это сделает контракт явным и проверяемым.

## 3. Неявное предположение о длине списка в InitiatorBotPlugin._parse_query
```python
def _parse_query(self, text: str) -> t.List[str]:
    query = re.findall(CREATE_TASK_RE, text)
    if len(query) < 3:
        raise exceptions.FillRequisitionError(...)
    # ...
    if len(query) == 3:
        query.append('DLK')
    return query
```

Использование:
```python
service, command, args, team_id = self._parse_query(message.text)
```

Проблема:
Метод `_parse_query` гарантирует, что вернет список длиной *минимум* 4 элемента (если исходно было 3, он добавляет 4-й). Однако он *не гарантирует* верхнюю границу. Если регулярное выражение найдет 5 совпадений, метод вернет список из 5 элементов.
Вызывающий код (`create_task`) использует распаковку в 4 переменные: `service, command, args, team_id = ....` Это приведет к `ValueError`, если элементов больше 4.
Ошибка модульного рассуждения здесь в том, что контракт `_parse_query` (возвращает `List[str]`) слишком широк для требований вызывающего кода (требуется `List[str]` длиной ровно 4). Глядя на `_parse_query`, мы не видим проблемы, но она возникает при стыковке с вызывающим кодом, который делает неявное предположение о точной длине списка.

Как исправить:
Изменить возвращаемый тип метода `_parse_query` на типизированный объект (`DTO`) или `NamedTuple`, либо явно ограничивать длину списка.
Вариант с `DTO` предпочтительнее:
```python
@dataclass
class TaskRequest:
    service: str
    command: str
    args: str
    team_id: str

def _parse_query(self, text: str) -> TaskRequest:
    # ... логика парсинга ...
    return TaskRequest(service=..., command=..., args=..., team_id=...)
```
Это сделает контракт жестким: метод всегда возвращает объект с 4 полями, и ошибка распаковки станет невозможной.

## 4. Зависимость бизнес-логики от реализации TaskLocator в TaskProcessing
```python
async def create_task(self, ...):
    # ...
    task = models.Task.create(...)
    self._task_locator.add_task_id_key(task, str(task.task_id))
    # ...
```
Проблема:
В методе `create_task` происходит явное добавление созданной задачи в `_task_locator` через `add_task_id_key`.
Это нарушает инкапсуляцию. Бизнес-логика создания задачи должна знать о том, что существует какой-то in-memory кэш (`TaskLocator`), который нужно обновить вручную. Если мы посмотрим на `TaskLocator`, то увидим, что это просто обертка над словарем.
Ошибка рассуждения заключается в том, что корректность работы системы (возможность потом найти эту задачу) зависит не от надежного сохранения в БД (которое тоже происходит), а от побочного эффекта ручного обновления кэша в контроллере. Если разработчик забудет вызвать `add_task_id_key` в другом месте создания задачи, система сломается, хотя с точки зрения БД всё будет корректно. Модуль `TaskProcessing` берет на себя ответственность за целостность данных другого модуля (`TaskLocator`).

Как исправить:
Скрыть работу с кэшем (`TaskLocator`) внутри репозитория `TaskRepository` или использовать паттерн `Decorator/Proxy` для репозитория.
При сохранении задачи (`repository.save(task)`) репозиторий должен сам обновлять кэш (если он используется). Бизнес-логика (`TaskProcessing`) должна работать только с абстракцией репозитория и не должна знать о существовании `TaskLocator` и необходимости его ручного обновления.

---

## Итоги

Раньше я часто писал код, который "просто работает", не задумываясь о том, *почему* он работает. Теперь я вижу, что многие мои решения держались на "честном слове" и знании деталей реализации других модулей. Например, я мог использовать глобальную переменную, будучи уверенным, что "она точно инициализируется в `main.py`", или парсить строку, зная, что "там всегда будет 3 пробела".

Понятие `Modular Reasoning` открыло мне глаза на то, что хороший код - это код, который можно понять и проверить изолированно. Если мне нужно прочитать 5 других файлов, чтобы понять, корректна ли одна функция - значит, я что-то делаю не так.

Внедрение явных спецификаций и избавление от скрытых зависимостей (как в примерах выше) делает систему не просто "рабочей", а надежной и понятной. Это позволяет менять один модуль, не боясь сломать половину системы в неожиданных местах. Кажется, именно это отличает инженерию от "кодинга".