# Как ослабить ограничения ORM-ов?

## 1. Разделение слоёв: Domain ≠ ORM

После знакомства с DDD понял, что одна из самых сильных практик — не связывать доменную модель напрямую с ORM-моделью.

Создаются:  
- Domain-модели (чистые объекты) — не содержат ни id, ни fk, ни аннотаций из SQLAlchemy/Django.
- Data-модели (ORM-specific) — отвечают только за маппинг и persistence.

Это даёт вам свободу мыслить бизнес-сущностями, а не таблицами.

## 2.  Писать SQL напрямую

Ручной SQL часто:
- проще читается;
- легче оптимизируется;
- работает быстрее;

Хороший компромисс — использовать ORM для CRUD и чистый SQL для Query-выборок.

## 3. Выносить связи за пределы объектов

Не каждое отношение стоит писать прямо внутрь модели.

Пример: `user.current_car_id` можно убрать вообще, если:
- текущее использование машины — это состояние;
- оно должно жить в другой сущности (например, `Reservation` или `UsageSession`).

## 4. Альтернатива REST + ORM: Event-based и Snapshot-based подходы

**Event sourcing** — сохраняем только события, а не текущие состояния. Модель — это производное.  
**CQRS** — читаем не из таблиц, а из сгенерированных представлений (snapshot'ов, projection'ов).  
**Bounded Contexts** — каждый микросервис/модуль знает только о себе, общение — через события, а не через FK.  

## Выводы

Раньше я автоматически добавлял `id`, `foreign key`, делал "таблички", не задумываясь. Теперь стараюсь сначала описать, что реально происходит в системе, какими действиями и смысловыми объектами всё управляется, и только потом думаю, как это сохранить.

Особенно часто я стал об этом задумываться после знакомства с `DDD` (`Domain-Driven Design`) — оно помогает видеть в данных не просто структуру, а поведение, роли и границы ответственности. Я больше не леплю id-шники просто потому что "так принято". Сначала — модель, потом — хранилище, а не наоборот.

`ORM` — это всего лишь инструмент.