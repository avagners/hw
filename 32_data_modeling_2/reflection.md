# Мутабельность как упрощение модели данных

```python
class A:
    def __init__(self, name):
        self.name = name


# Словарь для хранения "расширения"
extra_info_map = {}

# Создание объектов
a1 = A("Object 1")
a2 = A("Object 2")

# Добавление "дополнительного поля"
extra_info_map[id(a1)] = {"extra_info": "Value for Object 1"}
extra_info_map[id(a2)] = {"extra_info": "Value for Object 2"}

# Доступ к дополнительным данным
print(extra_info_map[id(a1)]["extra_info"])  # Output: Value for Object 1
print(extra_info_map[id(a2)]["extra_info"])  # Output: Value for Object 2
```

Ключом может быть:  
- `id(obj)`: уникальный идентификатор объекта во время его жизни.
- `hash(obj)`: если класс A реализует метод `__hash__` и поддерживает сравнение `__eq__`.

Я думаю при таком подходе идет усложнение модели данных. 
Поля больше не являются частью объекта, а разнесены по разным структурам. Это делает код менее очевидным и может запутать других разработчиков.

## Выводы

Честно говоря, сначала решение со словарём показалось мне странным и слегка "костыльным".
Почему бы просто не добавить поле в класс или создать наследника? Но после составления примера вник в суть.  

Это неплохой вариант, когда нельзя трогать оригинальный код или делать наследование ради одной фичи выглядит переусложнённым.

Динамическое расширение — это мощная штука. Добавлять новые поля на лету, да ещё и без вмешательства в структуру класса, оказалось удобно.
Но важно помнить, что модель данных становится сложнее. Теперь информация про объект расползается между классом и внешним словарём.

Я бы не стал использовать это везде, где надо что-то дописать. 
Но если нельзя менять класс, а задача требует лёгкого расширения — это решение выглядит практично.
