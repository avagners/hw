# 1. Ошибки модульного рассуждения в проекте

## Тип 1. Зависимость от более строгого результата, чем гарантируется спецификацией

### 1.1. Зависимость от возврата None 
```python
except exceptions.CommandNotFound:
    return None
```

**Анализ предусловий:**
*   **Спецификация validate_task:** Выполняет валидацию задачи.
    *   *Постусловие:* Задача провалидирована или выброшено исключение.
*   **Реализация `validate_task:validate_task`:** Возвращает `None` при ошибке `CommandNotFound`.
*   **Ожидание вызывающего кода:** Ожидает, что `None` означает "валидация не требуется" или "успех", хотя это может скрывать ошибку конфигурации.

**Суть ошибки:**
Вызывающий код может интерпретировать `None` как успешное завершение, хотя на самом деле команда не была найдена. Это зависимость от того, что `None` является "безопасным" результатом, хотя спецификация валидации подразумевает строгую проверку.

**Как исправить:**
Явно выбрасывать исключение или возвращать объект результата валидации.

### 1.2. Зависимость от реализации get_or_default
```python
def get_or_default(self, plugin_name: str) -> ITaskExecutor:
    for e in self._executors:
        # ...
```

**Анализ предусловий:**  
*   **Спецификация `get_or_default`:** Возвращает исполнителя для плагина или дефолтного.
    *   *Постусловие:* Возвращен ITaskExecutor.
*   **Реализация:** Возвращает первый попавшийся исполнитель, если конкретный не найден (или падает, если список пуст - тут реализация не очевидна из ф
*   **Ожидание вызывающего кода:** Ожидает, что "дефолтный" исполнитель подойдет для любой задачи.

**Суть ошибки:**
Код зависит от того, что дефолтный исполнитель (например, `SSH`) сможет выполнить задачу любого плагина. Если появится плагин, требующий специфического `API` (например, `HTTP`), дефолтный исполнитель сломает задачу, хотя метод `get_or_default` формально отработал верно.

**Как исправить:**
Убрать "default" поведение или гарантировать, что дефолтный исполнитель действительно универсален.

## Тип 2. Зависимость от возможности использовать более мягкие реализации, чем гарантирует спецификация

### 2.1. Игнорирование результата execute в validate_task
```python
await executor.execute(task)
```

**Анализ предусловий:**  
*   **Спецификация `executor.execute`**: Выполняет задачу.
    *   *Постусловие*: Задаче выполнена, возможны побочные эффекты или исключения.
*   **Реализация**: Выполняет команду, может выбросить исключение при ошибке. 
*   **Действия вызывающего кода**: Вызывает метод и игнорирует результат.

**Суть ошибки**:  
Код полагается на то, что `execute` выбросит исключение в случае неудачи валидации. Если реализация `execute` изменится так, что она будет возвращать статус (`True/False`) вместо исключения, валидация молча пройдет успешно даже при ошибке. Мы зависим от "мягкой" обработки ошибок (через исключения), которая не зафиксирована в контракте как единственный способ сообщить о неудаче.

**Как исправить:**:  
Явно проверять результат выполнения или статус задачи после `execute`.

### 2.2. Использование get_by_id для проверки существования
```python
    await self._user_repository.get_user_with_active_profile(user_id)
return True
```

**Анализ предусловий:**  
*   **Спецификация get_user_with_active_profile**: Возвращает пользователя.
    *   *Предусловие*: Пользователь существует и активен.
*   **Реализация**: Выбрасывает исключение, если пользователя нет.
*   **Действия вызывающего кода**: Использует метод получения данных как метод проверки, полагаясь на исключения.

**Суть ошибки**:  
Мы используем метод получения данных не по назначению, полагаясь на то, что он "упадет" в нужном нам случае. Если реализация изменится (например, начнет возвращать `None` или `NullUser`), логика проверки сломается (вернет `True` для несуществующего пользователя).

**Как исправить:**:  
Использовать явный метод `exists(user_id)` или `is_active(user_id)`.

# 2. Анализ применения принципа робастности (закона Постела)

## Парсинг команд
```python
@classmethod
def _parse_query(cls, query: str) -> t.Tuple[str, str]:
    # ...
    # Ищем команду после флага -c
    for i, part in enumerate(parts):
        if part == "-c" and i + 1 < len(parts):
            command = parts[i + 1]
            break
    # ...
    return command, dag_prefix
```

**Анализ условий:**
*   **Спецификация (идеальная)**:
    *   *Предусловие:* Строка `query` содержит валидную команду с флагом `-c`.
    *   *Постусловие:* Возвращена пара (`command`, `dag_prefix`).
*   **Реализация (по Постела)**:
    *   *Ослабленное предусловие:* Строка `query` может быть любой (пустой, без флагов, мусором).
    *   *Постусловие:* Возвращена пара строк, возможно пустых ("", ""), если парсинг не удался.

**Суть проблемы:**
Код пытается извлечь смысл из любой строки, даже если она некорректна. Это может привести к тому, что система неправильно классифицирует команду (например, вернет тег `EMPTY` вместо ошибки), и логика пойдет по ветке "по-умолчанию", вместо того чтобы сообщить пользователю о неверном формате запроса.

**Как исправить:**
Если строка должна содержать команду, но парсер не может её найти, то следует  выбросить исключительние.


# Итоги:

Пожалуй, это одно из сложнейших заданий за последнее время. Оно потребовало хорошо напрячь голову, пытаясь распутать клубок связей в коде и выявить спецификации, которые не прописаны явно в виде пред- и пост- условий прямо в коде. 

Это правда довольно сложная и ресурсоемкая работа. После выполения упражнения я ощутил сильную потребносить в наличии явного указания спецификаций в коде. 
Это позволило бы значительно легче читать код и выявить ошибки. 

Раньше я смотрел в код функции: "Ага, она возвращает список или `None`, значит, проверю на `None`". Теперь я понимаю, что надо смотреть на *контракт* (спецификацию). Если функция обещает вернуть список, а возвращает `None` - это ошибка реализации, а не повод мне писать проверку на наличие `None`. Подстраиваясь под кривую реализацию, я делаю свой код зависимым от этой ошибки.

Еще у меня был какой-то страх выкидывать исключения. Кажется теперь я понимаю почему у меня так было. Дело в том, что я не мыслил на 3-м уровне - на уровне спецификаций. Я думал, что следует обрабатывать максимально возможные варианты входных данных (вспоминаем закон Постела), что в корне не верно (особенно для внутренних систем). Мы должны на границе системы парсить входные данные, преобразовывать в строгие доменные типы и вслучае выявления данных, которые не соответсвуют предусловиям, смело выбрасывать исключение. Отказ от принципа Постела в пользу "Fail Fast" делает систему более предсказуемой и надежной.

