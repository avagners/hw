# F-ограниченный полиморфизм

F-ограниченный полиморфизм: «я типизирован самим собой».

В Python с 3.11 F-ограниченный полиморфизм (F-bounded quantification), выражаемый в виде `interface Stack<T extends Stack<T>>`, чтобы методы возвращали "тот же самый" тип реализации, можно реализовать с помощью `typing.Self` (PEP 673).

Функциональный интерфейс можно реализовать с помощью структурной типизации через `typing.Protocol` (static duck typing).

```python
from typing import Protocol, Self

# Первый контракт: поведение как у стека
class Stack(Protocol):
    def push(self: Self, x: int) -> Self: ...
    def pop(self: Self) -> tuple[int, Self]: ...

# Второй контракт: поведение как у коллекции
class Sized(Protocol):
    def __len__(self) -> int: ...

# Третий контракт: преобразование в список
class ToList(Protocol):
    def to_list(self) -> list[int]: ...


# ---- Реализация ----
class ListStack:
    def __init__(self, items=None):
        self._items = list(items) if items else []

    def push(self, x: int) -> Self:
        return ListStack([x] + self._items)

    def pop(self) -> tuple[int, Self]:
        if not self._items:
            raise IndexError("empty stack")
        return self._items[0], ListStack(self._items[1:])

    def __len__(self) -> int:
        return len(self._items)

    def to_list(self) -> list[int]:
        return list(self._items)

    def __repr__(self):
        return f"ListStack({self._items})"


# ---- Функции, работающие с разными интерфейсами ----
def use_as_stack(s: Stack):
    val, rest = s.push(10).pop()
    print("Stack use:", val, rest)

def use_as_sized(s: Sized):
    print("Sized use: length =", len(s))

def use_as_listable(s: ToList):
    print("ToList use:", s.to_list())


if __name__ == "__main__":
    s = ListStack([1, 2, 3])
    use_as_stack(s)     # подходит как Stack
    use_as_sized(s)     # подходит как Sized
    use_as_listable(s)  # подходит как ToList
```

Это ровно то, о чём писал Харпер:
"Одна реализация может соответствовать многим интерфейсам."

## Выводы

Тема оказалась крайне интересной! Пришлось погрузиться в номинативную и структурную типизации, историю создания `ABC` и `Protocol`. Даже узнал что `Go` сразу пошел по пути структурной типизации и это оказалось очень удобным. Именно это вдохновило `PEP 544` и только через 10 лет в `Python` добавил `Protocol`.

Я понял, зачем нужен F-ограниченный полиморфизм и что это такое. Он гарантирует, что метод интерфейса возвращает «тот же самый тип реализации», а не абстрактный суперкласс.

До этого казалось странным, зачем в интерфейсе возвращать «самого себя». Но когда попробовал реализовать стек как иммутабельную структуру, стало ясно: без этого при `push/pop` я теряю конкретный тип реализации и остаётся абстрактный `Stack`. С `Self` (или `TypeVar` с `bound`) Python умеет понимать, что метод возвращает именно `ListStack` или `DequeStack`.

С `Protocol` можно описать интерфейс, а любая реализация «вписывается» автоматически, если у неё есть методы нужной формы. Это гораздо гибче, чем жёсткое наследование от `ABC`. Теперь я понимаю, что это ближе к идеям Харпера про «модули как типы».

Один класс может реализовывать сразу несколько протоколов. Я могу взять старый класс, объявить новый протокол, и мой класс автоматически ему подходит - ничего не меняя в коде.

Я начал лучше чувствовать разницу между номинативной (наследование с `ABC`) и структурной типизацией (`Protocol`).

Функциональные интерфейсы в Python вполне реализуемы c помощью `Protocol + Self` - можно выразить идеи модульности и F-bounded.

Главное открытие!  
Модульность - это не про наследование, а про то, что мы можем описывать контракты так, чтобы разные реализации свободно подходили под них. F-ограниченный полиморфизм и `Protocol` дают в Python почти те же возможности, что Харпер описывал для ML.

