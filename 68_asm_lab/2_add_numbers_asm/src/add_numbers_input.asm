section .data
    prompt1 db 'Enter first number: '          ; Текст первого запроса
    prompt1_length equ $ - prompt1             ; Вычисление длины первого запроса (текущая позиция - начало prompt1)
    prompt2 db 'Enter second number: '         ; Текст второго запроса
    prompt2_length equ $ - prompt2             ; Вычисление длины второго запроса
    result_msg db 'The result is: '            ; Текст сообщения с результатом
    result_msg_length equ $ - result_msg       ; Вычисление длины сообщения с результатом
    newline db 0xA                             ; Символ новой строки (ASCII 10)
    newline_length equ $ - newline             ; Вычисление длины символа новой строки

section .bss
    num1 resb 16                               ; Резервируем 16 байт для первого числа (буфер ввода)
    num2 resb 16                               ; Резервируем 16 байт для второго числа (буфер ввода)
    result resb 16                             ; Резервируем 16 байт для результата (буфер вывода)

section .text
    global _start                              ; Объявляем _start глобальной меткой для линкера

_start:
    ; Вывод prompt1
    mov rax, 1                                 ; Номер системного вызова: 1 = write (запись)
    mov rdi, 1                                 ; Файловый дескриптор: 1 = stdout (стандартный вывод)
    mov rsi, prompt1                           ; Указатель на строку для вывода
    mov rdx, prompt1_length                    ; Длина выводимой строки
    syscall                                    ; Вызов ядра для выполнения системного вызова

    ; Чтение num1
    mov rax, 0                                 ; Номер системного вызова: 0 = read (чтение)
    mov rdi, 0                                 ; Файловый дескриптор: 0 = stdin (стандартный ввод)
    mov rsi, num1                              ; Указатель на буфер для ввода
    mov rdx, 16                                ; Максимальное количество байт для чтения
    syscall                                    ; Вызов ядра для чтения ввода

    ; Вывод prompt2
    mov rax, 1                                 ; write
    mov rdi, 1                                 ; stdout
    mov rsi, prompt2                           ; Указатель на второй запрос
    mov rdx, prompt2_length                    ; Длина второго запроса
    syscall                                    ; Вывод второго запроса

    ; Чтение num2
    mov rax, 0                                 ; read
    mov rdi, 0                                 ; stdin
    mov rsi, num2                              ; Указатель на буфер для второго числа
    mov rdx, 16                                ; Максимальная длина ввода
    syscall                                    ; Чтение второго числа

    ; Преобразование num1 в число
    mov rdi, num1                              ; Передаем указатель на первую строку в rdi
    call atoi                                  ; Вызываем функцию преобразования строки в число
    mov r8, rax                                ; Сохраняем результат (первое число) в регистре r8

    ; Преобразование num2 в число
    mov rdi, num2                              ; Передаем указатель на вторую строку в rdi
    call atoi                                  ; Преобразуем вторую строку в число
    mov r9, rax                                ; Сохраняем результат (второе число) в регистре r9

    ; Сложение
    add r8, r9                                 ; Складываем r8 и r9, результат сохраняется в r8

    ; Преобразование результата в строку (упрощенная версия)
    mov rdi, result                            ; Передаем указатель на буфер результата
    mov rax, r8                                ; Передаем число для преобразования
    call itoa_simple                           ; Вызываем функцию преобразования числа в строку

    ; Вывод результата
    mov rax, 1                                 ; write
    mov rdi, 1                                 ; stdout
    mov rsi, result_msg                        ; Указатель на текст "The result is: "
    mov rdx, result_msg_length                 ; Длина текста результата
    syscall                                    ; Вывод сообщения о результате

    mov rax, 1                                 ; write
    mov rdi, 1                                 ; stdout
    mov rsi, result                            ; Указатель на буфер с числом-результатом
    mov rdx, 16                                ; Длина вывода (16 байт)
    syscall                                    ; Вывод самого числового результата

    mov rax, 1                                 ; write
    mov rdi, 1                                 ; stdout
    mov rsi, newline                           ; Указатель на символ новой строки
    mov rdx, newline_length                    ; Длина символа новой строки
    syscall                                    ; Вывод перевода строки

    ; Завершение
    mov rax, 60                                ; Номер системного вызова: 60 = exit (завершение программы)
    xor rdi, rdi                               ; Обнуляем rdi (код возврата 0 = успешное завершение)
    syscall                                    ; Завершение программы

; Функция atoi (такая же как выше)
atoi:
    xor rax, rax                               ; Обнуляем rax (здесь будет накапливаться результат)
    xor rcx, rcx                               ; Обнуляем rcx (временно не используется)
    mov rcx, 10                                ; Устанавливаем основание системы счисления (10 для десятичной)
.next_digit:
    movzx rdx, byte [rdi]                      ; Загружаем следующий байт из строки и расширяем до 64 бит с нулями
    test rdx, rdx                              ; Проверяем, не является ли символ нулем (конец строки)
    jz .done                                   ; Если конец строки, переходим к метке .done
    cmp rdx, 0xA                               ; Проверяем, не является ли символ новой строки (ASCII 10)
    je .done                                   ; Если новая строка, переходим к .done
    cmp rdx, 0xD                               ; Проверяем, не является ли символ возврата каретки (ASCII 13)
    je .done                                   ; Если возврат каретки, переходим к .done
    sub rdx, '0'                               ; Преобразуем символ в цифру: вычитаем код символа '0'
    imul rax, rcx                              ; Умножаем текущий результат на 10 (сдвигаем разряды)
    add rax, rdx                               ; Добавляем новую цифру к результату
    inc rdi                                    ; Переходим к следующему символу в строке
    jmp .next_digit                            ; Повторяем цикл для следующего символа
.done:
    ret                                        ; Возвращаем результат в rax

; Упрощенная itoa - работает напрямую с буфером результата
itoa_simple:
    mov rbx, 10                                ; Устанавливаем делитель (основание системы счисления)
    mov rdi, result                            ; Загружаем адрес буфера результата
    add rdi, 15                                ; Перемещаемся к концу буфера (позиция 15)
    mov byte [rdi], 0                          ; Записываем нулевой байт (терминатор строки)
    
    test rax, rax                              ; Проверяем, не равно ли число нулю
    jnz .convert                               ; Если не ноль, переходим к преобразованию
    dec rdi                                    ; Если ноль, перемещаемся на одну позицию назад
    mov byte [rdi], '0'                        ; Записываем символ '0'
    jmp .end                                   ; Переходим к концу функции
    
.convert:
    dec rdi                                    ; Двигаемся назад по буферу (для следующей цифры)
    xor rdx, rdx                               ; Обнуляем rdx для операции деления
    div rbx                                    ; Делим rax на 10: rax = частное, rdx = остаток
    add dl, '0'                                ; Преобразуем цифру (0-9) в символ ('0'-'9')
    mov [rdi], dl                              ; Сохраняем символ в текущую позицию буфера
    test rax, rax                              ; Проверяем, не равно ли частное нулю
    jnz .convert                               ; Если не ноль, продолжаем преобразование
    
.end:
    ; Теперь rdi указывает на начало строки
    ; Для вывода нам нужно знать длину
    ret                                        ; Возвращаем управление