# 2-3 программы на ассемблере x86-64

## 1. Hello, World (hello.asm)
Чему научился:
- Структура программы: Понял, что программа делится на секции .data (данные) и .text (код)
- Системные вызовы: Осознал, что все взаимодействия с ОС происходят через syscall
- Базовый синтаксис: Узнал про директивы db, equ, метку _start:
- Процесс сборки: Научился компилировать NASM и линковать с ld

Приобретенные навыки:
- Написал первую работающую программу на ASM
- Узнал про номера системных вызовов (1 = write, 60 = exit)
- Понял важность корректного завершения программы

## 2. Add Numbers (add_numbers_input.asm)

Чему научился:
- Работа с памятью: Понял разницу между .data (константы) и .bss (переменные)
- Ввод данных: Освоил системный вызов read (rax=0) для чтения с клавиатуры
- Преобразование типов: Написал первые функции atoi (строка → число) и itoa (число → строка)
- Арифметика: Узнал про инструкцию add для сложения чисел

Ключевые инсайты:
```asm
section .bss
    num1 resb 16    ; Понял, что это "пустые ячейки" для данных
```

- Открытие: Процессор не различает "строки" и "числа" - только байты
- Осознал: Все преобразования типов - это наша ответственность
- Понял алгоритм: atoi - это последовательное "цифра × 10 + следующая цифра"

Приобретенные навыки:
- Работа с буферами ввода
- Организация кода через функции (call, ret)
- Использование регистров для передачи аргументов (rdi) и возврата результатов (rax)
- Отладка многошаговых программ

## 3. Dynamic Array (dynarray.asm)

Чему научился:
- Динамическая память: Освоил системные вызовы для управления памятью (mmap, munmap)
- Структуры данных: Реализовал динамический массив с автоматическим расширением
- Указатели и адресация: Понял арифметику указателей [base + index * size]
- Управление ресурсами: Осознал важность освобождения памяти

Ключевые инсайты:
- Прорыв: Узнал, что malloc() в C и списки в Python - это обертки над системными вызовами
- Понял: "Динамический" массив = фиксированные блоки + перевыделение при необходимости
- Осознал: Индексация массива - это вычисление смещения: адрес_начала + индекс × размер_элемента

Приобретенные навыки:
- Работа с динамической памятью
- Реализация алгоритмов расширения массивов
- Использование системных вызовов для управления памятью
- Организация сложных структур данных на низком уровне

## Выводы

Когда я впервые посмотрел как реализуется вывод "Hello, World!", это выглядело как инопланетный язык.
Мои мысли тогда: "Что за db? Что такое equ? Почему 0xA? И что это за доллар $ тут делает?
Я видел кучу непонятных символов и чувствовал себя полным новичком.

Понимание стало появляться, когда я стал комментировать каждую строчку кода. В этом мне помогли, в том числе, LLM.
```asm
_start:
    ; ========================= ВЫВОД СООБЩЕНИЯ =========================
    mov rax, 1      ; Говорим ядру: "Мы хотим выполнить ВЫВОД (sys_write)"
    mov rdi, 1      ; Куда выводим: "На экран (stdout = 1)"
    mov rsi, msg    ; Что выводим: "Вот адрес нашей строки" 
    mov rdx, len    ; Сколько выводим: "Вот длина строки"
    syscall         ; "Ядро, выполни пожалуйста!"

    ; ======================= ЗАВЕШЕНИЕ ПРОГРАММЫ =======================
    mov rax, 60     ; Говорим ядру: "Мы хотим ЗАВЕРШИТЬ программу (sys_exit)"
    mov rdi, 0      ; С каким статусом: "Успешно (код 0)"
    syscall         ; "Ядро, заверши программу пожалуйста!"
```

После этого стало значительно понятнее. 
Я понял, что программа не "просто работает", а ведет диалог с операционной системой.
Каждый syscall - это вежливая просьба: "Ядро, сделай вот это, пожалуйста".

rax = 1 значит "хочу выводить", rax = 60 значит "хочу завершиться".

Узнал, что у программ есть "стандартные потоки". Осознал, что ввод/вывод - это просто работа с предопределенными каналами.

"Что выводим: Вот адрес нашей строки" - прорыв в понимании памяти.
Понял разницу между данными и адресами данных. msg - это не сама строка, а указатель на строку в памяти. Осознал, что процессор не работает напрямую с данными, а только с их адресами. Нужно явно указывать длину - никакой магии, только прямой контроль.

До комментариев:

```asm
mov rax, 1    ; ??? Какое-то число
mov rdi, 1    ; ??? Еще число  
mov rsi, msg  ; ??? Переменная какая-то
syscall       ; ??? Магия!
```

После комментариев:

```asm
mov rax, 1    ; Ставлю номер услуги "вывод"
mov rdi, 1    ; Указываю канал "экран"  
mov rsi, msg  ; Передаю что выводить
mov rdx, len  ; Уточняю сколько выводить
syscall       ; Вызываю исполнителя!
```

После этого исчез страх перед "непонятным кодом" - теперь я вижу не набор команд, а диалог.


