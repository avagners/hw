# Ускоряем код фреймворков в 100 раз - 2

## 1. Примеры проблем с дефолтным поведением
### Пример 1. Отсутствие явного порядка при работе с ORM

Используя Django ORM, я получил список пользователей с ролями, предполагая, что они будут упорядочены по id.

```python
users = User.objects.filter(role__name='Admin')
```
После обновления базы данных или фреймворка данные начали возвращаться в случайном порядке.

**Ошибка:**  
Это не ошибка ORM — я ошибочно предположил, что порядок будет сохранён, хотя это нигде не гарантируется.

**Решение:**  
Явно указал сортировку:

```python
users = User.objects.filter(role__name='Admin').order_by('id')
```

### Пример 2. Предположение о кешировании результатов API

В REST API внешнего сервиса я выполнял один и тот же запрос несколько раз, ожидая, что результаты будут закешированы.

```python
data = api.get_data("some_query")
```
На каждом вызове данные подгружались с нуля, создавая ненужную нагрузку.

**Ошибка:**  
Моя. Я не изучил документацию API, где было сказано, что кеширование нужно настраивать отдельно.

**Решение:**  
Добавил свой уровень кеширования:

```python
from cachetools import cached, TTLCache

cache = TTLCache(maxsize=100, ttl=300)

@cached(cache)
def get_cached_data(query):
    return api.get_data(query)
```

### Пример 3. "Автоматическая" обработка временных зон

Используя библиотеку обработки дат (например, pytz), я предположил, что библиотека автоматически добавляет временные зоны при сериализации.

```python
from datetime import datetime
now = datetime.now()
```
В базе данных сохранялось время без временной зоны, что создавало путаницу при обработке данных из разных регионов.

**Ошибка:**  
Моя. Я не проверил документацию, где чётко указано, что временную зону нужно добавлять вручную:

```python
from datetime import datetime
import pytz

now = datetime.now(pytz.UTC)
```

**Решение:**  
Убедился, что временные зоны учитываются везде, где это нужно, и добавил автоматизацию при сериализации.

### Выводы
1) Не полагаться на дефолтное поведение. 
2) Изучать документацию и исходный код.
3) Явно задавать свойства, которые важны для логики вашего проекта.
4) Документировать свои предположения, например, в пред- и пост- условиях.
5) Тестировать код.


## 2. Пользовательский тип результата функции/метода

### Пример 1. Исключение неоднозначностей при работе с упорядоченностью
Было:
```python
def get_users_with_roles():
    # Возвращает список пользователей с их ролями
    return User.objects.all()
```
**Проблема:**  
Этот метод возвращает простой список, подразумевая порядок, хотя порядок не имеет значения для дальнейшей обработки.
Если кто-то будет полагаться на упорядоченность результата, это может привести к багам.

Стало:
```python
from typing import Set

def get_users_with_roles() -> Set[User]:
    # Возвращаем множество, чтобы явно показать, что порядок не имеет значения
    return set(User.objects.all())
```
**Преимущество:**  
Использование `Set` исключает зависимость от порядка и чётко указывает, что порядок не имеет значения.

### Пример 2. Уточнение результата функции фильтрации
Было:
```python
def find_admin_users():
    return User.objects.filter(role='Admin')
```
**Проблема:**  
Тип результата не уточняет, может ли список быть пустым. Это заставляет клиентов метода гадать, нужно ли проверять наличие элементов.

Стало:
```python
from typing import List, Optional

def find_admin_users() -> Optional[List[User]]:
    users = list(User.objects.filter(role='Admin'))
    return users if users else None
```

**Преимущество:**  
Использование `Optional[List]` чётко сигнализирует, что метод может вернуть None, если администраторов нет.

### Пример 3. Введение пользовательского типа результата для сложных данных

Было:
```python
def get_user_report():
    return {
        "name": "John",
        "age": 30,
        "orders": [100, 200, 300]
    }
```

**Проблема:**  
Возврат словаря делает работу с результатом неявной, что приводит к возможным ошибкам. Например, можно случайно изменить ключ или неправильно интерпретировать его значение.

Стало:
```python
from dataclasses import dataclass
from typing import List

@dataclass
class UserReport:
    name: str
    age: int
    orders: List[int]

def get_user_report() -> UserReport:
    return UserReport(name="John", age=30, orders=[100, 200, 300])
```
**Преимущество:**  
Использование `dataclass` делает структуру данных явной, предотвращая ошибки, связанные с использованием "сырых" словарей.

### Выводы

1) Явно указывать тип результата  
Использование структур данных (например, `Set`, `Optional`, `dataclass`) вместо универсальных типов (например, `List`, `dict`) исключает нежелательные формы обработки результата.
2) Создавать пользовательские типы данных  
Создание кастомных типов данных повышает читаемость кода и снижает вероятность ошибок.
3) Документировать намерения  
Тип результата чётко передаёт разработчикам, что можно (или нельзя) делать с возвращаемыми данными.